<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator><link href="https://shvtr159.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://shvtr159.github.io/" rel="alternate" type="text/html" /><updated>2021-03-07T19:55:17+09:00</updated><id>https://shvtr159.github.io/feed.xml</id><title type="html">Study Blog</title><subtitle>for study</subtitle><author><name>KYG</name></author><entry><title type="html">3DMatch: Learning the Matching of Local 3D Geometry in Range Scans - 요약</title><link href="https://shvtr159.github.io/%EB%85%BC%EB%AC%B8/paper_3dmatch/" rel="alternate" type="text/html" title="3DMatch: Learning the Matching of Local 3D Geometry in Range Scans - 요약" /><published>2021-03-03T00:00:00+09:00</published><updated>2021-03-03T00:00:00+09:00</updated><id>https://shvtr159.github.io/%EB%85%BC%EB%AC%B8/paper_3dmatch</id><content type="html" xml:base="https://shvtr159.github.io/%EB%85%BC%EB%AC%B8/paper_3dmatch/">&lt;h2 id=&quot;3-geometric-representation&quot;&gt;3. Geometric Representation&lt;/h2&gt;
&lt;p&gt;geometric matching의 목표는 3D geometry의 ‘fragments’간 robust한 대응관계를 만드는 것이다.&lt;/p&gt;

&lt;h2 id=&quot;5-geometric-matching-network&quot;&gt;5. Geometric Matching Network&lt;/h2&gt;
&lt;p&gt;unified deep neural network 구조를 사용.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;feature network : 3D ConvNet을 이용하여 local 3D TDF volume을 고차원 feature representation에 mapping.&lt;/li&gt;
  &lt;li&gt;metric network : fully connected 내적 layer들의 set를 통해 feature의 쌍들을 similarity value에 mapping.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;네트워크 구조
1, 각 query keypoint의  주변의 local TDF volume이 geometric fragment에서 crop된다. 이 volume들은 독립적으로 feature network를 통해 전달되어 2048개의 요소가 포함된 feature descriptor에 mapping. 이 feature vector들의 쌍들이 연결되고 metric network를 통해 공급된다. 이 network는 두 point의 유사도를 측정하는 match score로 끝이 난다.
2, 데이터로부터 최고의 distance function을 자동으로 학습&lt;/p&gt;
&lt;h3 id=&quot;51-네트워크-구조&quot;&gt;5.1 네트워크 구조&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Geometric feature network&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;키포인트의 3D local region을 간결한 feature 표현에 매핑하는 descriptor 함수로 구성. 
Input : 31x31x31의 voxel TDF volume인 반면, feature 표현은 2048차원의 feature vector이다. Feature network는 convolutional layer(ReLU)와 하나의 polling layer로 구성.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Metric network&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;두 feature representations은 비교하고 두 relevant keypoints가 서로 일치하는지 결정하는 Non-linear 매칭 function. 
Input : 두 feature vector의 concatenation. 
output : keypoint간 유사도를 나타내는 0~1의 confidence value.
몇몇의 fully connected layer로 구성(ReLu). 마지막 layer는 Softmax를 사용하고 이 두 value는 각각 두 feature들이 일치하고, 일치하지 않는 확률의 network estimate.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Matcing cost&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;t-Stochastic Neighbor Embedding (t-SNE) : vector visualization을 위하여 자주 이용되는 알고리즘. 차원 축소와 시각화 방법론으로 널리 쓰인다. SNE는 n 차원에 분포된 이산 데이터를 k(n 이하의 정수) 차원으로 축소하며 거리 정보를 보존하되, 거리가 가까운 데이터의 정보를 우선하여 보존하기 위해 고안되었다. 연속적인 확률 분포(가우시안 분포)로서 가중치를 부여한다. t-SNE는 SNE에서 가우시안 분포 대신 t 분포를 사용한다.
스토캐스틱 gradient descent를 이용. 식의 yi 는 binary label(O or X), input xi 와 yihat 은 softmax layer의 output으로 나온 확률 estimate&lt;/p&gt;

&lt;h3 id=&quot;52-feature-visualization&quot;&gt;5.2. Feature Visualization&lt;/h3&gt;</content><author><name>KYG</name></author><category term="논문" /><summary type="html">3. Geometric Representation geometric matching의 목표는 3D geometry의 ‘fragments’간 robust한 대응관계를 만드는 것이다.</summary></entry><entry><title type="html">Harris corner detector</title><link href="https://shvtr159.github.io/computer%20vision/harris/" rel="alternate" type="text/html" title="Harris corner detector" /><published>2021-03-02T00:00:00+09:00</published><updated>2021-03-02T00:00:00+09:00</updated><id>https://shvtr159.github.io/computer%20vision/harris</id><content type="html" xml:base="https://shvtr159.github.io/computer%20vision/harris/">&lt;p&gt;이미지에서 코너는 edge 등에 비해 noise와 같은 문제에도 안정적으로 descriptor의 역할을 할 수 있습니다. 
이 때 corner를 찾기 위해서 사용하는 알고리즘 중 harris corner detector에 대해서 알아봅니다.&lt;/p&gt;

&lt;h2 id=&quot;1-basic-idea&quot;&gt;1. Basic idea&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;flat :  지역에서는 모든 방향으로 변화가 없음&lt;/li&gt;
  &lt;li&gt;edge : 영역에서는 edge 방향으로는 변화가 없으나 이에 수직한 방향으로는 변화가 있음.&lt;/li&gt;
  &lt;li&gt;corner : 대부분의 뱡향으로 변화가 있음.&lt;br /&gt;
&lt;img src=&quot;https://user-images.githubusercontent.com/79836443/109519097-426a4d00-7aee-11eb-929c-12effbe45adc.png&quot; alt=&quot;change&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 변화를 측정하기 위해 작은 윈도우(window)를 설정하고 이 윈도우를 x축 방향으로 u, y축 방향으로 v 만큼 이동시킵니다.
이때 수식은 다음과 같습니다.&lt;/p&gt;

\[\sum_{x,y} w(x,y)[I(x+u,y+v)-I(x,y)]^{2}\]

&lt;p&gt;x축, y축 방향 모두에 대해 변화가 크다면 이 값도 커지므로, 이 값이 크면 corner로 봅니다. 이때 $w(x, y)$는 window function으로 필요에 따라 uniform이나 Gaussian 등을 사용할 수 있습니다.
이 식은 Taylor series로 인해 다음과 같이 근사할 수 있습니다.&lt;/p&gt;

&lt;p&gt;\(\approx \sum_{} [I(x,y)+uI_{x}+vI_{y}-I(x,y)]^{2}\)
\(= \sum_{} u^{2}I_{x}^{2}+2uvI_{x}I_{y}+v^{2}I^{2}\)&lt;/p&gt;

&lt;p&gt;그리고 이를 행렬로 나타내면 다음과 같이 됩니다.&lt;/p&gt;

\[= \begin{bmatrix} u&amp;amp;v \end{bmatrix}\sum_{}\left ( \begin{bmatrix} I_{x}^{2} &amp;amp; I_{x}I_{y}\\ I_{x}I_{y} &amp;amp; I_{y}^{2} \end{bmatrix}\right )\begin{bmatrix} u\\ v \end{bmatrix}\]

&lt;p&gt;이때, 가운데 2x2 행렬을 Harris Matrix라고 부르며, corner 외에도 사용이 가능합니다.&lt;/p&gt;

&lt;h2 id=&quot;2-corner-판단&quot;&gt;2. Corner 판단&lt;/h2&gt;
&lt;p&gt;위 Harris Matrix를 &lt;strong&gt;고유값 분해&lt;/strong&gt; 하면 2개의 고유값(eigen value)와 고유벡터(eigen vector)들을 얻을 수 있습니다. 여기서 고유값이 크다는 의미는 이 고유값에 대응하는 고유벡터의 방향으로 변화가 크다는 것을 의미합니다. &lt;strong&gt;즉 corner는 대부분의 방향으로 변화가 있다고 했기때문에 고유값 분해로 얻어지는 2개의 고유값 모두 크다면 그 위치가 corner임을 알 수 있습니다.&lt;/strong&gt; 이에 반해 하나의 고유값만이 크다면 한쪽 방향으로 변화가 생기는 부분이므로 edge, 고유값이 모두 작다면 변화가 크지 않은 위치이므로 flat한 영역임을 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;그렇다면 어떻게 Harris Matrix의 고유값과 고유벡터가 이미지의 변화와 관련이 있는 것일까요?
이는 선형대수의 Rank와 관련이 있습니다.  ~~flat는 rank가 0, 1, 2.~이렇게 됨. 고유값은 다를수 있으나 고유벡터 방향은 일치~&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/79836443/109627618-2665ba80-7b85-11eb-8506-9f9592eaaa85.jpg&quot; alt=&quot;eigenvalue&quot; class=&quot;align-center&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그러나 매번 고유값과 고유벡터를 계산하는것은 계산해야할것이 많기때문에 다음 식을 이용해 더 간단히 판단합니다.&lt;/p&gt;

\[R = det(M) - k(trace(M))^{2}      (k = 0.04 - 0.06)\]

\[det(M) = \lambda_{1}\lambda_{2}\]

\[trace(M) = \lambda_{1} + \lambda_{2}\]

&lt;p&gt;이 식을 통해 R이 계산되어 두 고유값의 변화에 따라 R은 다음과 같은 결과를 얻게 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/79836443/109629591-51510e00-7b87-11eb-9ab6-aa594c3a1358.jpg&quot; alt=&quot;R&quot; class=&quot;align-center&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;결국 R값이 0보다 충분히 큰 부분을 찾게되면 그 부분을 코너로 판단할 수 있는것입니다.&lt;/p&gt;
&lt;h2 id=&quot;3-3d-harris-detector&quot;&gt;3. 3D Harris detector&lt;/h2&gt;
&lt;p&gt;이 방식은 x, y, z 좌표를 사용하는 3차원 좌표계에서도 사용할 수 있습니다.
point cloud를 이용하는 Point Cloud Library의 HarrisKeypoint3D라는 함수의 정의 부분을 보면&lt;/p&gt;
&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;trace&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;covar&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;covar&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;covar&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
       &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;trace&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
       &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
         &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;det&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;covar&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;covar&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;covar&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;2.0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;covar&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;covar&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;covar&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
                   &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;covar&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;covar&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;covar&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
                   &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;covar&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;covar&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;covar&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
                   &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;covar&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;covar&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;covar&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
  
         &lt;span class=&quot;n&quot;&gt;output&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pIdx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;intensity&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.04&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;det&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.04&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;trace&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;trace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
       &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;와 같은 부분이 있습니다다. covar 배열은
\(\begin{pmatrix} xx(0) &amp;amp; xy(1) &amp;amp; xz(2)\\ yx(1) &amp;amp; yy(5) &amp;amp; yz(6)\\ zx(2) &amp;amp; zy(6) &amp;amp; zz(7) \end{pmatrix}\)
의 행렬을 나타내는 배열로, 대각식(trace)를 계산한 뒤
아래 사루스 법칙을 사용하여 행렬식(det)을 계산하였습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/79836443/109632291-3502a080-7b8a-11eb-9d8c-593650f22312.png&quot; alt=&quot;determinant&quot; class=&quot;align-center&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이후 output[pInx].intensity = 에서 2차원에서 R과 다르게 k가 det에도 곱해져있지만 전체적으로는 유사한 방법으로 R을 계산하여 3차원 공간 상의 corner를 찾아낼 수 있습니다.&lt;/p&gt;</content><author><name>KYG</name></author><category term="Computer Vision" /><summary type="html">이미지에서 코너는 edge 등에 비해 noise와 같은 문제에도 안정적으로 descriptor의 역할을 할 수 있습니다. 이 때 corner를 찾기 위해서 사용하는 알고리즘 중 harris corner detector에 대해서 알아봅니다.</summary></entry></feed>